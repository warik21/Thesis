
# test_utils.py - Generated by CodiumAI

import pytest
import numpy as np

from utils.utils import unbalanced_sinkhorn

"""
Code Analysis:
- The main use case of the function is to solve unbalanced optimal transport (OT) problems.
The goal of the function is to output the transport plan, f_i and g_j, which are equal to the optimal transport potentials of the UOT(alpha, beta) problem.

Inputs:
- alpha: source distribution and weights
- beta: target distribution and weights
- costs: cost matrix
- eps: regularization parameter
- max_iter: maximum number of iterations

Flow:
- Initialize f and g to zero
- While the number of iterations is less than the maximum number of iterations:
    - Update g using the unbalanced Sinkhorn algorithm
    - Approximate g using the KL divergence
    - Update f using the unbalanced Sinkhorn algorithm
    - Approximate f using the KL divergence
    - Increment the number of iterations

Outputs:
- f: transport plan for the source distribution
- g: transport plan for the target distribution
"""

"""
Test Plan:
- test_valid_inputs(): tests that the function returns the expected output when valid inputs are provided. Tags: [happy path]
- test_empty_alpha(): tests that the function raises a ValueError when alpha is empty. Tags: [edge case]
- test_empty_beta(): tests that the function raises a ValueError when beta is empty. Tags: [edge case]
- test_different_shapes(): tests that the function handles cases where alpha and beta have different shapes, and where costs has different shape than alpha and beta. Tags: [general behavior]
- test_empty_costs(): tests that the function raises a ValueError when costs is empty. Tags: [edge case]
- test_eps_zero(): tests that the function raises a ValueError when eps is zero. Tags: [edge case]
- test_max_iter_zero(): tests that the function raises a ValueError when max_iter is zero. Tags: [edge case]
- test_negative_alpha(): tests that the function raises a ValueError when alpha has negative values. Tags: [edge case]
- test_negative_beta(): tests that the function raises a ValueError when beta has negative values. Tags: [edge case]
- test_negative_costs(): tests that the function raises a ValueError when costs has negative values. Tags: [edge case]
"""



class TestUnbalancedSinkhorn:
    def test_valid_inputs(self):
        alpha = np.array([0.2, 0.3, 0.5])
        beta = np.array([0.1, 0.4, 0.5])
        costs = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        f, g, plan = unbalanced_sinkhorn(alpha, beta, costs, return_plan=True)
        assert f.shape == beta.shape
        assert g.shape == alpha.shape
        assert np.allclose(plan.sum(axis=1), alpha, atol=1e-5)
        assert np.allclose(plan.sum(axis=0), beta, atol=1e-5)

    def test_empty_alpha(self):
        alpha = np.array([])
        beta = np.array([0.1, 0.4, 0.5])
        costs = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        with pytest.raises(ValueError):
            unbalanced_sinkhorn(alpha, beta, costs)

    def test_empty_beta(self):
        alpha = np.array([0.2, 0.3, 0.5])
        beta = np.array([])
        costs = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        with pytest.raises(ValueError):
            unbalanced_sinkhorn(alpha, beta, costs)

    def test_different_shapes(self):
        alpha = np.array([0.2, 0.3, 0.5])
        beta = np.array([0.1, 0.4])
        costs = np.array([[1, 2], [4, 5], [7, 8]])
        with pytest.raises(ValueError):
            unbalanced_sinkhorn(alpha, beta, costs)

    def test_empty_costs(self):
        alpha = np.array([0.2, 0.3, 0.5])
        beta = np.array([0.1, 0.4, 0.5])
        costs = np.array([])
        with pytest.raises(ValueError):
            unbalanced_sinkhorn(alpha, beta, costs)

    def test_eps_zero(self):
        alpha = np.array([0.2, 0.3, 0.5])
        beta = np.array([0.1, 0.4, 0.5])
        costs = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        with pytest.raises(ValueError):
            unbalanced_sinkhorn(alpha, beta, costs, eps=0)

